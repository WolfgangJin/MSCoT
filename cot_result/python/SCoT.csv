"Let's think step by step
Input: operations: a list of integers representing deposits and withdrawals
Output: a boolean value indicating whether the balance falls below zero at any point
1: Initialize a variable named balance to 0
2: for each operation in operations:
3:     Add the operation value to balance
4:     if balance is less than 0:
5:         return True
6: return False"
"Let's think step by step
Input: numbers: a list of integers
Output: a tuple (sum of numbers, product of numbers)
1: Initialize sum to 0
2: Initialize product to 1
3: for each number in numbers:
4:     Add number to sum
5:     Multiply product by number
6: return (sum, product)"
"Let's think step by step
Input: a: a string of 1s and 0s, b: a string of 1s and 0s
Output: a string representing the binary XOR of a and b
1: Ensure both strings a and b are of the same length
2: Initialize an empty string result to store the XOR result
3: for each index i from 0 to the length of a:
4:     if character at index i in a is the same as character at index i in b:
5:         Append '0' to result
6:     else:
7:         Append '1' to result
8: return result"
"Let's think step by step
Input: strings: a list of strings
Output: the longest string in the list or None if the list is empty
1: If the list strings is empty:
2:     return None
3: Initialize a variable max_length_string with the first string in the list
4: for each string str in strings starting from the second element:
5:     if the length of str is greater than the length of max_length_string:
6:         Update max_length_string to be str
7: return max_length_string"
"Let's think step by step
Input: a: an integer, b: an integer
Output: the greatest common divisor of a and b
1: while b is not equal to 0:
2:     Assign the value of b to a temporary variable temp
3:     Assign the remainder of a divided by b to b
4:     Assign the value of temp to a
5: return a"
"Let's think step by step
Input: numbers: a space-delimited string of numberals from 'zero' to 'nine'
Output: a string with numbers sorted from smallest to largest
1: Create a dictionary to map numberals to their corresponding numeric values
2: Split the input string into a list of numberals
3: Convert each numeral in the list to its corresponding numeric value using the dictionary
4: Sort the list of numeric values
5: Convert each numeric value back to its corresponding numeral using the dictionary
6: Join the sorted list of numerals into a space-delimited string
7: return the sorted string"
"Let's think step by step
Input: numbers: a list of at least two floating-point numbers
Output: a list of rescaled numbers where the smallest number becomes 0 and the largest becomes 1

1: Find the minimum value (min_val) in the numbers list
2: Find the maximum value (max_val) in the numbers list
3: Initialize an empty list named rescaled_numbers to store the transformed numbers
4: for each number (num) in numbers:
5:     Calculate the rescaled value using the formula: (num - min_val) / (max_val - min_val)
6:     Append the rescaled value to the rescaled_numbers list
7: return the rescaled_numbers list"
"Let's think step by step
Input: string: a string with characters in mixed case
Output: a string with the case of each character flipped
1: Initialize an empty string named flipped_string
2: for each character ch in string:
3:     if ch is lowercase:
4:         Convert ch to uppercase and add to flipped_string
5:     else if ch is uppercase:
6:         Convert ch to lowercase and add to flipped_string
7:     else:
8:         Add ch as it is to flipped_string (for non-alphabetic characters)
9: return flipped_string"
"Let's think step by step
Input: l: a list of numbers
Output: a list containing only the positive numbers from the input list
1: Initialize an empty list named positive_numbers
2: for each number num in l:
3:     if num is greater than 0:
4:         add num to positive_numbers
5: return positive_numbers"
"Let's think step by step
Input: n: an integer
Output: a boolean indicating if n is prime
1: if n is less than 2:
2:     return False
3: for i from 2 to the square root of n (inclusive):
4:     if n is divisible by i:
5:         return False
6: return True"
"Let's think step by step
Input: l: a list of elements
Output: a sorted list of unique elements
1: Initialize an empty set named unique_elements_set to store unique elements
2: for each element in l:
3:     Add the element to unique_elements_set (sets automatically handle duplicates by only keeping unique items)
4: Convert unique_elements_set to a list named unique_elements_list
5: Sort unique_elements_list in ascending order
6: return unique_elements_list"
"Let's think step by step
Input: n: an integer representing the n-th number to find
Output: the n-th number that is both a Fibonacci number and a prime number
1: Initialize a counter count to 0
2: Initialize a list fib_primes to store Fibonacci numbers that are also prime
3: Initialize two variables a and b to 0 and 1 respectively (starting values of Fibonacci sequence)
4: Loop until count is less than n:
5:     Calculate the next Fibonacci number by adding a and b, name it fib_next
6:     Update a to b and b to fib_next
7:     Check if fib_next is a prime number:
8:         Initialize a flag is_prime to True
9:         for i from 2 to the square root of fib_next:
10:            if fib_next is divisible by i:
11:                Set is_prime to False
12:                Break the loop
13:         If is_prime is True:
14:             Increment count by 1
15:             Append fib_next to the fib_primes list
16: Return the last element in fib_primes list"
"Let's think step by step
Input: l: a list of integers
Output: a boolean indicating if there are three distinct elements in the list that sum to zero
1: Initialize a variable found to False to keep track of whether a valid triplet is found
2: for each element i in the list from the start to the third last element:
3:     for each element j in the list starting from the element after i to the second last element:
4:         for each element k in the list starting from the element after j to the last element:
5:             if the sum of elements at i, j, and k is zero:
6:                 set found to True
7:                 break out of all loops
8: return the value of found"
"Let's think step by step
Input: l: a list of integers
Output: a boolean indicating if there are two distinct elements in the list that sum to zero
1: Initialize an empty set named seen_numbers
2: for each number num in l:
3:     Calculate the complement of num as -num
4:     if complement is in seen_numbers:
5:         return True
6:     Add num to seen_numbers
7: return False"
"Let's think step by step
Input: n: an integer representing the position in the fib4 sequence
Output: the n-th element of the fib4 number sequence
1: Initialize a list named fib4_sequence with the first four known values [0, 0, 2, 0]
2: if n is less than 4:
3:     return fib4_sequence[n]
4: else:
5:     for each index i from 4 to n:
6:         calculate the next fib4 value as fib4_sequence[i-1] + fib4_sequence[i-2] + fib4_sequence[i-3] + fib4_sequence[i-4]
7:         append the calculated value to fib4_sequence
8: return fib4_sequence[n]"
"Let's think step by step
Input: l: a list of numbers
Output: the median of the list l
1: Sort the list l in ascending order
2: Calculate the length of the list l and store it in a variable n
3: if n is odd:
4:     Find the middle element (element at index n//2)
5:     Return the middle element
6: else (n is even):
7:     Find the two middle elements (elements at indices n//2 - 1 and n//2)
8:     Calculate the average of the two middle elements
9:     Return the average as the median"
"Let's think step by step
Input: text: a string
Output: a boolean indicating if text is a palindrome
1: Initialize start index to 0
2: Initialize end index to the length of text minus 1
3: Loop while start index is less than end index:
4:     If character at start index is not equal to character at end index:
5:         return False
6:     Increment start index by 1
7:     Decrement end index by 1
8: return True"
"Let's think step by step
Input: text: a string
Output: a string with all vowels removed
1: Initialize an empty string named result
2: for each character ch in text:
3:     if ch is not a vowel (not 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'):
4:         Append ch to result
5: return result"
"Let's think step by step
Input: l: a list of numbers, t: an integer threshold
Output: a boolean value (True if all numbers in the list are below the threshold, False otherwise)
1: Initialize a boolean variable all_below to True
2: for each number num in list l:
3:     if num is greater than or equal to t:
4:         set all_below to False
5:         break the loop
6: return all_below"
"Let's think step by step
Input: x: an integer, y: an integer
Output: the sum of x and y
1: Start with the function add that takes two parameters x and y
2: Calculate the sum of x and y
3: return the result of the sum"
"Let's think step by step
Input: s0: a string, s1: a string
Output: a boolean indicating if s0 and s1 have the same characters
1: Create an empty dictionary to count characters in s0 named char_count_dict_s0
2: for each character ch in s0:
3:     if ch is not in char_count_dict_s0:
4:         Add ch to char_count_dict_s0 with a count of 1
5:     else:
6:         Increment the count of ch in char_count_dict_s0 by 1
7: Create an empty dictionary to count characters in s1 named char_count_dict_s1
8: for each character ch in s1:
9:     if ch is not in char_count_dict_s1:
10:        Add ch to char_count_dict_s1 with a count of 1
11:    else:
12:        Increment the count of ch in char_count_dict_s1 by 1
13: if char_count_dict_s0 is equal to char_count_dict_s1:
14:     return True
15: return False"
"Let's think step by step
Input: n: an integer
Output: the n-th Fibonacci number
1: Initialize two variables, a and b, to 0 and 1 respectively
2: if n is 0:
3:     return a
4: else:
5:     for i from 2 to n (inclusive):
6:         Create a new variable temp and set it to a + b
7:         Set a to b
8:         Set b to temp
9:     return b"
"Let's think step by step
Input: l1: a list, l2: a list
Output: a sorted list of unique common elements from l1 and l2
1: Initialize an empty set named common_elements
2: for each element e in l1:
3:     if e is also in l2:
4:         add e to common_elements
5: Convert common_elements to a list
6: Sort the list of common elements
7: return the sorted list"
"Let's think step by step
Input: n: an integer greater than 1 and not a prime
Output: the largest prime factor of n
1: Initialize a variable largest_factor to None
2: Initialize a variable factor to 2 (the smallest prime number)
3: while n is greater than 1:
4:     if n is divisible by factor:
5:         Set largest_factor to factor
6:         Divide n by factor
7:     else:
8:         Increment factor by 1
9: return largest_factor"
"Let's think step by step
Input: n: an integer
Output: the sum of all integers from 1 to n
1: Initialize a variable sum to 0
2: for each integer i starting from 1 to n (inclusive):
3:     Add i to sum
4: return sum"
"Let's think step by step
Input: xs: a list of coefficients representing a polynomial
Output: a list of coefficients representing the derivative of the polynomial
1: Initialize an empty list named derivative_coeffs to store the coefficients of the derivative
2: for i from 1 to the length of xs (excluding 0):
3:     Calculate the new coefficient by multiplying the current coefficient xs[i] by its power i
4:     Append the new coefficient to derivative_coeffs
5: return derivative_coeffs"
"Let's think step by step
Input: n: an integer representing the position in the fibfib sequence
Output: the n-th element of the fibfib number sequence
1: If n is 0 or 1:
2:     return 0
3: If n is 2:
4:     return 1
5: Initialize a list fibfib_sequence with the first three elements [0, 0, 1]
6: for i from 3 to n (inclusive):
7:     calculate the next fibfib number as fibfib_sequence[i-1] + fibfib_sequence[i-2] + fibfib_sequence[i-3]
8:     append this number to fibfib_sequence
9: return the last element in fibfib_sequence"
"Let's think step by step
Input: s: a string representing a word
Output: count: the number of vowels in the string s
1: Initialize a variable count to 0 to keep track of the number of vowels
2: Define a set of vowels, including 'a', 'e', 'i', 'o', 'u' in both lowercase and uppercase
3: for each character ch in s:
4:     if ch is in the set of vowels:
5:         increment count by 1
6: if the last character of s is 'y' or 'Y':
7:     increment count by 1
8: return count"
"Let's think step by step
Input: lst: a non-empty list of positive integers
Output: the greatest integer that has a frequency greater than or equal to its value, or -1 if no such integer exists
1: Initialize an empty dictionary named frequency_dict
2: for each num in lst:
3:     if num is already a key in frequency_dict:
4:         Increment the value associated with num in frequency_dict by 1
5:     else:
6:         Add num to frequency_dict with a value of 1
7: Initialize a variable named result with a value of -1
8: for each key value pair in frequency_dict:
9:     if value (frequency) is greater than or equal to key (the number):
10:        if key is greater than result:
11:            Update result with the value of key
12: return result"
"Let's think step by step
Input: a, b, c: lengths of the three sides of a triangle
Output: area of the triangle rounded to 2 decimal points or -1 if not a valid triangle
1: Check if the given sides form a valid triangle
2:     if a + b > c and a + c > b and b + c > a:
3:         Proceed to calculate the area
4:     else:
5:         return -1
6: Calculate the semi-perimeter of the triangle
7:     s = (a + b + c) / 2
8: Calculate the area using Heron's formula
9:     area = sqrt(s * (s - a) * (s - b) * (s - c))
10: Round the area to 2 decimal points
11: Return the rounded area"
"Let's think step by step
Input: q: a list, w: an integer (maximum possible weight)
Output: True if q is balanced (palindromic) and the sum of its elements is less than or equal to w, otherwise False
1: Check if the list q is palindromic
2:     Initialize is_balanced as True
3:     for i from 0 to the length of q divided by 2:
4:         if the element at index i is not equal to the element at index (length of q - i - 1):
5:             set is_balanced to False
6:             break
7: Calculate the sum of the elements in q
8:     Initialize total_weight as 0
9:     for each element in q:
10:        add the element to total_weight
11: Check if is_balanced is True and total_weight is less than or equal to w
12:     if both conditions are met:
13:         return True
14:     otherwise:
15:         return False"
"Let's think step by step
Input: a: an integer less than 100
Output: a boolean indicating if a is the product of 3 prime numbers
1: Define a helper function to check if a number is prime
   1.1: for i from 2 to sqrt(number):
       1.1.1: if number is divisible by i:
           1.1.1.1: return False
   1.2: return True
2: Initialize a list named primes to store all prime numbers less than 100
3: for i from 2 to 99:
   3.1: if i is prime:
       3.1.1: append i to primes
4: for i in primes:
   4.1: for j in primes:
       4.1.1: for k in primes:
           4.1.1.1: if i * j * k equals a:
               4.1.1.1.1: return True
5: return False"
"Let's think step by step
Input: decimal: an integer in decimal form
Output: a string in binary format with 'db' at the beginning and the end
1: Convert the decimal number to binary using Python's bin() function
2: Remove the '0b' prefix that bin() adds to the binary string
3: Add 'db' to the beginning of the binary string
4: Add 'db' to the end of the binary string
5: return the modified binary string"
"Let's think step by step
Input: s: a string
Output: a boolean indicating if the string is happy
1: If the length of s is less than 3:
2:     return False
3: for each index i from 0 to len(s) - 3:
4:     Extract the substring of length 3 starting at index i
5:     If the three characters in the substring are not distinct:
6:         return False
7: return True"
"Let's think step by step
Input: grades: a list of GPAs
Output: a list of corresponding letter grades

1: Initialize an empty list called letter_grades
2: for each gpa in grades:
3:     if gpa == 4.0:
4:         append 'A+' to letter_grades
5:     else if gpa > 3.7:
6:         append 'A' to letter_grades
7:     else if gpa > 3.3:
8:         append 'A-' to letter_grades
9:     else if gpa > 3.0:
10:        append 'B+' to letter_grades
11:    else if gpa > 2.7:
12:        append 'B' to letter_grades
13:    else if gpa > 2.3:
14:        append 'B-' to letter_grades
15:    else if gpa > 2.0:
16:        append 'C+' to letter_grades
17:    else if gpa > 1.7:
18:        append 'C' to letter_grades
19:    else if gpa > 1.3:
20:        append 'C-' to letter_grades
21:    else if gpa > 1.0:
22:        append 'D+' to letter_grades
23:    else if gpa > 0.7:
24:        append 'D' to letter_grades
25:    else if gpa > 0.0:
26:        append 'D-' to letter_grades
27:    else:
28:        append 'E' to letter_grades
29: return letter_grades"
"Let's think step by step
Input: string: a string
Output: Boolean: True if the length of the string is a prime number, False otherwise
1: Define a helper function is_prime(num) to check if a number is prime
    1.1: if num is less than 2, return False
    1.2: for each i from 2 to the square root of num (inclusive):
        1.2.1: if num is divisible by i, return False
    1.3: return True
2: Calculate the length of the input string
3: Use the is_prime function to check if the length of the string is a prime number
4: Return the result of the is_prime function"
"Let's think step by step
Input: N: a positive integer
Output: a binary string representing the sum of digits of N in binary
1: Initialize sum_of_digits to 0
2: Convert N to a string to iterate through each digit
3: for each character digit in the string representation of N:
4:     Convert digit back to an integer
5:     Add integer value of digit to sum_of_digits
6: Convert sum_of_digits to a binary string
7: Remove the '0b' prefix from the binary string
8: Return the binary string"
"Let's think step by step
Input: lst: a 2-dimensional list (nested lists), x: an integer
Output: a list of tuples representing coordinates (row, column) of x in lst
1: Initialize an empty list named coordinates
2: for each row_index in the range of the length of lst:
3:     for each column_index in the range of the length of lst[row_index]:
4:         if the element at lst[row_index][column_index] is equal to x:
5:             create a tuple (row_index, column_index)
6:             append the tuple to coordinates
7: sort coordinates by row_index in ascending order
8: for each row in the unique row indices in coordinates:
9:     filter tuples in coordinates that have row_index equal to row
10:    sort these filtered tuples by column_index in descending order
11:    replace the original tuples in coordinates with the sorted ones
12: return coordinates"
"Let's think step by step
Input: lst: a list of integers
Output: the second smallest integer in lst or None if it doesn't exist
1: If the length of lst is less than 2:
2:     return None
3: Initialize two variables smallest and second_smallest with None
4: for each number num in lst:
5:     if smallest is None or num < smallest:
6:         second_smallest = smallest
7:         smallest = num
8:     elif (second_smallest is None or num < second_smallest) and num != smallest:
9:         second_smallest = num
10: return second_smallest"
"Let's think step by step
Input: S: a string of words
Output: the number of sentences starting with ""I""
1: Initialize a counter named boredom_count to 0
2: Split the string S into sentences using '.', '?', and '!' as delimiters
3: for each sentence in the list of sentences:
4:     Strip leading and trailing whitespace from the sentence
5:     Check if the sentence starts with the word ""I"":
6:         Increment boredom_count by 1
7: return boredom_count"
"Let's think step by step
Input: lst: a list of integers
Output: an integer representing the sum of the digits of the largest prime number in the list

1: Define a helper function is_prime(n) to check if a number n is prime:
1.1: if n is less than 2:
1.1.1: return False
1.2: for i from 2 to the square root of n, inclusive:
1.2.1: if n is divisible by i:
1.2.1.1: return False
1.3: return True

2: Initialize a variable largest_prime to None

3: for each number num in lst:
3.1: if num is prime (using is_prime function):
3.1.1: if largest_prime is None or num is greater than largest_prime:
3.1.1.1: set largest_prime to num

4: if largest_prime is None:
4.1: return 0 (or some value indicating no prime found)

5: Initialize a variable digit_sum to 0

6: while largest_prime is greater than 0:
6.1: add the last digit of largest_prime to digit_sum
6.2: remove the last digit from largest_prime

7: return digit_sum"
"Let's think step by step
Input: dict: a dictionary with keys and values
Output: True if all string keys are in the same case (either all lower or all upper), False otherwise
1: If the dictionary is empty:
2:     return False
3: Initialize two flags - all_lower to True and all_upper to True
4: for each key in the dictionary:
5:     if the key is not a string:
6:         return False
7:     if the key is not all lower case:
8:         set all_lower to False
9:     if the key is not all upper case:
10:        set all_upper to False
11: if all_lower or all_upper is True:
12:     return True
13: return False"
"Let's think step by step
Input: value: a string representing a number
Output: the closest integer to the value, rounding away from zero if equidistant
1: Convert the string value to a float named number
2: Check if number is positive:
    2.1: If positive, use the math.ceil function if the decimal part of number is 0.5 or more, otherwise use math.floor
    2.2: If negative, use the math.floor function if the decimal part of number is -0.5 or less, otherwise use math.ceil
3: Return the resulting integer from step 2"
"Let's think step by step
Input: n: a positive integer representing the number of levels
Output: a list where each element represents the number of stones in each level
1: Initialize an empty list named pile
2: Set current_stones to n
3: for i from 0 to n-1 (inclusive):
4:     Add current_stones to the pile list
5:     if n is odd:
6:         Increment current_stones by 2 (to get the next odd number)
7:     else:
8:         Increment current_stones by 2 (to get the next even number)
9: return pile"
"Let's think step by step
Input: s: a string of words separated by commas or spaces
Output: a list of words from the string
1: Remove any commas from the string s
2: Split the modified string by spaces to get a list of words
3: Initialize an empty list named words_list
4: for each word in the split string:
5:     if the word is not an empty string:
6:         Add the word to words_list
7: return words_list"
"Let's think step by step
Input: x, y: two positive numbers
Output: the biggest even integer in the range [x, y] inclusive, or -1 if no such number exists
1: Check if x is greater than y:
2:     if true, return -1 because the range is invalid
3: Initialize a variable max_even to -1
4: for each number num in the range from x to y inclusive:
5:     if num is even:
6:         if num is greater than max_even:
7:             set max_even to num
8: return max_even"
"Let's think step by step
Input: n: a positive integer, m: a positive integer
Output: the binary representation of the rounded average of integers from n through m, or -1 if n > m
1: Check if n is greater than m:
2:     if n > m:
3:         return -1
4: Initialize a variable sum to 0
5: Initialize a variable count to 0
6: for each integer i from n to m (inclusive):
7:     Add i to sum
8:     Increment count by 1
9: Calculate the average: average = sum / count
10: Round the average to the nearest integer: rounded_average = round(average)
11: Convert the rounded average to binary: binary_representation = bin(rounded_average)
12: return binary_representation"
"Let's think step by step
Input: n: an integer
Output: a list of size n where each element at index i (starting from 1) is the factorial of i if i is even or the sum of numbers from 1 to i if i is odd
1: Initialize an empty list named result
2: for each integer i from 1 to n (inclusive):
3:     if i is even:
4:         Initialize a variable factorial to 1
5:         for each integer j from 1 to i:
6:             Multiply factorial by j
7:         Add factorial to result
8:     else:
9:         Initialize a variable sum to 0
10:        for each integer j from 1 to i:
11:           Add j to sum
12:        Add sum to result
13: return result"
"Let's think step by step
Input: n: a positive integer
Output: a tuple with the number of even and odd integer palindromes within the range (1, n), inclusive
1: Initialize two counters, even_count to 0 and odd_count to 0
2: for each integer i from 1 to n (inclusive):
3:     Convert i to a string and check if it reads the same forwards and backwards (is a palindrome):
4:         if i is an integer palindrome:
5:             if i is even:
6:                 Increment even_count by 1
7:             else:
8:                 Increment odd_count by 1
9: return a tuple (even_count, odd_count)"
"Let's think step by step
Input: arr: a list of N integers with unique elements
Output: a boolean indicating if the array can be sorted in non-decreasing order by performing right shift operations
1: If arr is empty:
2:     return True
3: Initialize a variable count to 0
4: for i from 0 to length of arr - 1:
5:     if arr[i] > arr[i + 1]:
6:         increment count by 1
7:     if i is the last index:
8:         compare arr[i + 1] with arr[0]
9:         if arr[i + 1] > arr[0]:
10:            increment count by 1
11: if count is less than or equal to 1:
12:    return True
13: else:
14:    return False"
"Let's think step by step
Input: lst1: a list of numbers, lst2: a list of numbers
Output: a string ""YES"" or ""NO"" indicating if it's possible to make all elements of lst1 even by exchanging elements with lst2
1: Check if all elements in lst1 are already even:
2:     if true:
3:         return ""YES""
4:     else:
5:         Go to step 6
6: Initialize a counter for odd numbers in lst1
7: for each number in lst1:
8:     if the number is odd:
9:         increment the counter for odd numbers in lst1
10: Initialize a counter for even numbers in lst2
11: for each number in lst2:
12:     if the number is even:
13:         increment the counter for even numbers in lst2
14: if the counter for even numbers in lst2 is greater than or equal to the counter for odd numbers in lst1:
15:     return ""YES""
16: else:
17:     return ""NO"""
"Let's think step by step
Input: s: a string, c: a string containing characters to be removed from s
Output: a tuple containing the result string and a boolean indicating if it's a palindrome
1: Initialize an empty string named result
2: for each character ch in s:
3:     if ch is not in c:
4:         Add ch to the result string
5: Initialize a boolean variable is_palindrome to True
6: for i from 0 to length of result divided by 2:
7:     if character at position i in result is not equal to character at position (length of result - i - 1) in result:
8:         Set is_palindrome to False
9: return a tuple containing result and is_palindrome"
"Let's think step by step
Input: 
    grid: a 2D list (rectangular grid of wells) where each 1 represents a unit of water
    capacity: an integer representing the capacity of the buckets
Output: 
    an integer representing the number of times the buckets need to be lowered

1: Initialize a variable named total_dips to 0 to keep track of the number of times buckets are lowered
2: for each row in grid:
    2.1: Initialize a variable named current_row_water to 0 to keep track of the water units in the current row
    2.2: for each cell in row:
            2.2.1: if cell contains water (i.e., cell is 1):
                2.2.1.1: increment current_row_water by 1
    2.3: Calculate the number of dips needed for the current row:
        2.3.1: if current_row_water is greater than 0:
            2.3.1.1: divide current_row_water by capacity using math.ceil to round up to the nearest integer
            2.3.1.2: add the result to total_dips
3: return total_dips"
"Let's think step by step
Input: s: a string, n: a natural number
Output: a list of words from s that contain exactly n consonants
1: Initialize an empty list named result to store words with exactly n consonants
2: Split the string s into a list of words named words
3: for each word in words:
4:     Initialize a counter consonant_count to 0
5:     for each character ch in word:
6:         if ch is a consonant (i.e., not a vowel and is an alphabetic character):
7:             Increment consonant_count by 1
8:     if consonant_count is equal to n:
9:         Add word to result
10: return result"
"Let's think step by step
Input: arr: a list of integers, k: an integer
Output: a sorted list of length k with the maximum k numbers in arr
1: Initialize an empty list named max_numbers
2: if k is 0:
3:     return max_numbers
4: for each number num in arr:
5:     Add num to max_numbers
6: Sort max_numbers in ascending order
7: Return the last k elements of max_numbers"
"Let's think step by step
Input: arr: a list of integers, k: an integer
Output: an integer representing the sum of elements with at most two digits from the first k elements of arr
1: Initialize a variable sum to 0
2: for each element i from 0 to k-1 in arr:
3:     if the absolute value of arr[i] is less than 100:
4:         add arr[i] to sum
5: return sum"
"Let's think step by step
Input: interval1: a tuple of two integers, interval2: a tuple of two integers
Output: ""YES"" if the length of the intersection of interval1 and interval2 is a prime number, otherwise ""NO""
1: Determine the start and end points of the intersection
   1.1: Find the maximum of the start points of interval1 and interval2 as the start of the intersection
   1.2: Find the minimum of the end points of interval1 and interval2 as the end of the intersection
2: Calculate the length of the intersection
   2.1: If the start of the intersection is less than or equal to the end of the intersection, calculate the length as (end of intersection - start of intersection + 1)
   2.2: If the start of the intersection is greater than the end of the intersection, the intersection length is 0
3: Define a helper function to check if a number is prime
   3.1: A prime number is greater than 1
   3.2: A prime number is not divisible by any number other than 1 and itself
4: Use the helper function to check if the intersection length is a prime number
5: Return ""YES"" if the intersection length is a prime number, otherwise return ""NO"""
"Let's think step by step
Input: n: a non-negative integer
Output: a list of the first n + 1 numbers of the Tribonacci sequence
1: Initialize an empty list named tribonacci_list to store the sequence
2: Handle the base case:
   2.1: if n is 0, append 1 to tribonacci_list and return tribonacci_list
3: Append the first element 1 to tribonacci_list
4: if n is greater than or equal to 1:
   4.1: Append the second element 3 to tribonacci_list
5: if n is greater than or equal to 2:
   5.1: Append the third element 2 to tribonacci_list
6: for each i from 3 to n (inclusive):
   6.1: if i is even:
         6.1.1: Calculate the tribonacci value as 1 + i / 2
         6.1.2: Append the calculated value to tribonacci_list
   6.2: if i is odd:
         6.2.1: Calculate the tribonacci value as tribonacci_list[i - 1] + tribonacci_list[i - 2] + tribonacci_list[i + 1]
         6.2.2: Append the calculated value to tribonacci_list
7: return tribonacci_list"
"Let's think step by step
Input: n: a positive integer
Output: product of the odd digits in n, or 0 if all digits are even
1: Initialize a variable product to 1 to store the product of odd digits
2: Initialize a flag has_odd to False to check if there are any odd digits
3: Convert the integer n to a string to iterate over each digit
4: for each character digit in the string representation of n:
5:     Convert the character digit back to an integer
6:     if the digit is odd:
7:         Multiply the product by the digit
8:         Set has_odd to True
9: if has_odd is False:
10:    Return 0 (since there were no odd digits)
11: Return product (the product of the odd digits)"
"Let's think step by step
Input: string: a string containing only square brackets
Output: True if there is at least one nested bracket, otherwise False
1: Initialize a counter open_brackets to 0
2: Initialize a variable nested to False
3: for each character ch in string:
4:     if ch is an opening bracket '[':
5:         increment open_brackets by 1
6:     else if ch is a closing bracket ']':
7:         if open_brackets is greater than 0:
8:             decrement open_brackets by 1
9:             if open_brackets is greater than 0:
10:                set nested to True
11:        else:
12:            return False (because there are more closing brackets than opening ones)
13: if open_brackets is not equal to 0:
14:     return False (because there are unmatched opening brackets)
15: return nested"
"Let's think step by step
Input: lst: a list of numbers (integers or floats)
Output: an integer representing the sum of squares of the ceiling values of the numbers in lst

1: Initialize a variable named total_sum to 0
2: for each number num in lst:
3:     Calculate the ceiling value of num and store it in a variable named ceil_num
4:     Square ceil_num and store the result in a variable named square
5:     Add square to total_sum
6: return total_sum"
"Let's think step by step
Input: txt: a string
Output: True if the last character of txt is an alphabetical character and is not part of a word, otherwise False
1: Trim any trailing spaces from txt
2: if txt is empty:
3:     return False
4: Split txt into words using space as a delimiter
5: Get the last word from the list of words
6: if the last word has a length of 1 and is an alphabetical character:
7:     return True
8: return False"
"Let's think step by step
Input: arr: a list of integers without duplicates
Output: the largest index of an element which is not greater than or equal to the element immediately preceding it, or -1 if no such element exists
1: Initialize a variable max_index to -1
2: for i from 1 to the length of arr (exclusive):
3:     if the element at index i is less than the element at index i-1:
4:         Set max_index to i
5: return max_index"
"Let's think step by step
Input: lst: a list of integers
Output: a tuple (a, b) where 'a' is the largest of negative integers and 'b' is the smallest of positive integers
1: Initialize 'a' to None and 'b' to None
2: for each number num in lst:
3:     if num is less than 0:
4:         if 'a' is None or num is greater than 'a':
5:             set 'a' to num
6:     else if num is greater than 0:
7:         if 'b' is None or num is less than 'b':
8:             set 'b' to num
9: return the tuple (a, b)"
"Let's think step by step
Input: n: an integer greater than 0
Output: the special factorial of n
1: Initialize a variable result to 1 (this will hold the final special factorial value)
2: for each integer i from n down to 1:
3:     Initialize a variable factorial to 1 (this will hold the factorial of the current number i)
4:     for each integer j from i down to 1:
5:         Multiply factorial by j (calculate i!)
6:     Multiply result by factorial (accumulate i! into the special factorial)
7: return result"
"Let's think step by step
Input: sentence: a string representing a sentence
Output: a string containing words from the original sentence whose lengths are prime numbers
1: Define a function to check if a number is prime
    1.1: if number is less than 2, return False
    1.2: for i from 2 to the square root of number:
        1.2.1: if number is divisible by i, return False
    1.3: return True
2: Split the sentence into words
3: Initialize an empty list named prime_length_words
4: for each word in the list of words:
    4.1: if the length of the word is prime (using the is_prime function):
        4.1.1: Add the word to prime_length_words
5: Join the words in prime_length_words into a single string separated by spaces
6: return the resulting string"
"Let's think step by step
Input: x: a string representing a fraction, n: a string representing a fraction
Output: True if the product x * n is a whole number, False otherwise
1: Parse the string x to get numerator_x and denominator_x
2: Parse the string n to get numerator_n and denominator_n
3: Calculate the product of the numerators (numerator_product = numerator_x * numerator_n)
4: Calculate the product of the denominators (denominator_product = denominator_x * denominator_n)
5: Check if numerator_product is divisible by denominator_product without a remainder
6:     If true, return True
7:     Otherwise, return False"
"Let's think step by step
Input: nums: a list of integers
Output: a list of integers sorted by the sum of their digits, maintaining original order for ties
1: Define a helper function digit_sum to calculate the sum of digits of a number:
   1.1: Convert the number to its absolute value to handle negative numbers
   1.2: Convert the number to a string to iterate over each digit
   1.3: Initialize a sum variable to 0
   1.4: for each character in the string:
   1.4.1: Convert the character back to an integer
   1.4.2: Add the integer to the sum
   1.5: Return the sum
2: Create a list of tuples where each tuple contains:
   2.1: The sum of digits of the number (using the digit_sum function)
   2.2: The index of the number in the original list (to maintain order for ties)
   2.3: The number itself
3: Sort the list of tuples based on:
   3.1: The first element of each tuple (the sum of digits)
   3.2: The second element of each tuple (the index) for tie-breaking
4: Extract the third element (the number itself) from each tuple in the sorted list
5: Return the extracted numbers as a list"
"Let's think step by step
Input: nums: a list of integers
Output: count of numbers greater than 10 with both first and last digits odd
1: Initialize a counter to 0
2: for each number num in nums:
3:     if num is greater than 10:
4:         Convert num to a string to access first and last digits
5:         Check if the first digit of num is odd
6:             if the last digit of num is odd:
7:                 Increment the counter
8: return the counter"
"Let's think step by step
Input: n: a positive integer
Output: an integer representing the number of valid triples (a[i], a[j], a[k]) where i < j < k and a[i] + a[j] + a[k] is a multiple of 3
1: Initialize an empty list a to store the sequence
2: for i from 1 to n:
3:     Calculate the value i * i - i + 1
4:     Append the calculated value to list a
5: Initialize a counter to 0 to keep track of valid triples
6: for i from 0 to n-3:
7:     for j from i+1 to n-2:
8:         for k from j+1 to n-1:
9:             Calculate the sum of a[i], a[j], a[k]
10:            if the sum is divisible by 3:
11:               Increment the counter by 1
12: return the counter"
"Let's think step by step
Input: planet1: a string, planet2: a string
Output: a tuple of planet names between planet1 and planet2, sorted by proximity to the sun
1: Define a list of planets in order of their distance from the Sun
2: Initialize an empty list to store the planets between planet1 and planet2
3: if both planet1 and planet2 are in the planets list:
4:     find the index of planet1 in the planets list
5:     find the index of planet2 in the planets list
6:     if the index of planet1 is less than the index of planet2:
7:         for each planet in the planets list between the index of planet1 and the index of planet2:
8:             add the planet to the list of planets between
9:     else:
10:        for each planet in the planets list between the index of planet2 and the index of planet1:
11:            add the planet to the list of planets between
12: return the list of planets between as a tuple
13: else:
14:     return an empty tuple"
"Let's think step by step
Input: n: an integer, x: a value, y: a value
Output: x if n is a prime number, y otherwise
1: Define a function to check if a number is prime
    1.1: If n is less than 2, return False
    1.2: for each integer i from 2 to the square root of n:
        1.2.1: if n is divisible by i, return False
    1.3: return True
2: Check if n is a prime number using the defined function
3: if n is prime:
    3.1: return x
4: else:
    4.1: return y"
"Let's think step by step
Input: lst: a list of numbers
Output: sum of squares of odd, non-negative integers in lst
1: Initialize a variable sum_of_squares to 0
2: for each number num in lst:
3:     if num is an integer and num is non-negative and num is odd:
4:         square the number num
5:         add the squared number to sum_of_squares
6: return sum_of_squares"
"Let's think step by step
Input: class_name: a string, extensions: a list of strings
Output: a string in the format 'ClassName.StrongestExtensionName'
1: Initialize variables to keep track of the strongest extension and its strength
   strongest_extension = None
   max_strength = float('-inf')
2: for each extension in extensions:
   2.1: Initialize counters for uppercase and lowercase letters
        uppercase_count = 0
        lowercase_count = 0
   2.2: for each character ch in extension:
        2.2.1: if ch is uppercase:
                increment uppercase_count
        2.2.2: else if ch is lowercase:
                increment lowercase_count
   2.3: Calculate the strength of the current extension
        current_strength = uppercase_count - lowercase_count
   2.4: if current_strength is greater than max_strength:
        update strongest_extension to the current extension
        update max_strength to current_strength
3: Return the result in the required format
   return class_name + '.' + strongest_extension"
"Let's think step by step
Input: a: a string, b: a string
Output: True if any rotation of b is a substring in a, otherwise False
1: Initialize a variable rotations to store all rotations of b
2: for i from 0 to length of b - 1:
3:     Generate a rotation of b by taking the substring from i to the end and appending the substring from the start to i
4:     Add the generated rotation to rotations
5: for each rotation in rotations:
6:     if rotation is a substring of a:
7:         return True
8: return False"
"Let's think step by step
Input: number: a positive integer between 1 and 1000
Output: a string representing the Roman numeral equivalent of the number in lowercase
1: Define a dictionary to map integer values to Roman numeral strings
2: Initialize an empty string result to build the Roman numeral
3: for each (value, numeral) pair in the dictionary, sorted from largest to smallest:
4:     while number is greater than or equal to value:
5:         append numeral to result
6:         subtract value from number
7: return result in lowercase"
"Let's think step by step
Input: a, b, c: lengths of the three sides of a triangle
Output: True if the sides form a right-angled triangle, False otherwise
1: Sort the sides a, b, c to ensure the largest side is last
2: Assign the sorted sides to variables x, y, z where z is the largest
3: Check if the sum of the squares of the two smaller sides equals the square of the largest side (x^2 + y^2 == z^2):
4:     if True:
5:         return True
6:     else:
7:         return False"
"Let's think step by step
Input: s: a string
Output: a modified string with reversed case letters or reversed string if no letters are present
1: Initialize an empty string result to store the modified characters
2: Initialize a flag has_letters to False
3: for each character ch in s:
4:     if ch is a letter:
5:         set has_letters to True
6:         if ch is lowercase:
7:             convert ch to uppercase and add to result
8:         else:
9:             convert ch to lowercase and add to result
10:    else:
11:        add ch to result as it is
12: if has_letters is False:
13:     reverse the string s and return it
14: else:
15:     return result"
"Let's think step by step
Input: text: a string
Output: the md5 hash of the string, or None if the string is empty
1: Check if the input string 'text' is empty
2:     If it is empty, return None
3:     Otherwise, import the hashlib module
4:     Create an md5 hash object
5:     Update the hash object with the bytes of the input string
6:     Get the hexadecimal representation of the hash
7:     Return the hexadecimal hash string"
"Let's think step by step
Input: a: positive integer, b: positive integer
Output: a list of even digits between a and b (inclusive) in ascending order
1: Determine the lower and upper bounds between a and b
2: Initialize an empty list named even_digits_list
3: for each number num in the range from lower bound to upper bound (inclusive):
4:     if num is even:
5:         append num to even_digits_list
6: return even_digits_list"
